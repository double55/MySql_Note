# MySql分表、分库、分片和分区的区别

## 分片

分片是把数据库横向扩展(Scale Out)到多个物理节点上的一种有效的方式，其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。Shard这个词的意思是 “碎片” 。如果将一个数据库当作一块大玻璃，将这块玻璃打碎，那么每个小块都称为数据库的碎片（Database Shard）。将整个数据库打碎的过程叫做分片，可以翻译为分片。

## 垂直切分/水平切分

Scale Out(横向扩展)是指Application可以在水平方向上扩展。一般对数据中心的应用而言，Scale out指的是当添加更多的机器时，应用仍然可以很好的利用这些机器的资源来提升自己的效率从而达到很好的扩展性。

Scale Up(纵向扩展)是指Application可以在垂直方向上扩展。一般对单台机器而言，Scale Up值得是当某个计算节点(机器)添加更多的CPU Cores，存储设备，使用更大的内存时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性。

***MySql的Sharding策略包括垂直切分和水平切分两种。***

垂直(纵向)拆分:是指按功能模块拆分，以解决表与表之间的io竞争。比如分为订单库、商品库、用户库...这种方式多个数据库之间的表结构不同。

水平(横向)拆分:将同一个表的数据进行分块保存到不同的数据库中，来解决单表中数据量增长出现的压力。这些数据库中的表结构完全相同。

***表结构设计垂直切分。常见的一些场景包括***
a).大字段的垂直切分。单独将大字段建在另外的表中，提高基础表的访问性能，原则上在性能关键的应用中应当避免数据库的大字段
b)，按照使用用途垂直切分。例如企业物料属性，可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直切分
c)，按照访问频率垂直切分。例如电子商务、Web2.0系统中，如果用户属性设置非常多，可以将基本、使用频繁的属性和不常用的属性垂直切分开

***表结构设计水平切分。常见的一些场景包括***
a)，比如在线电子商务网站，订单表数据量过大，按照年度、月度水平切分
b)，Web2.0网站注册用户、在线活跃用户过多，按照用户ID范围等方式，将相关用户以及该用户紧密关联的表做水平切分
c)，例如论坛的置顶帖子，因为涉及到分页问题，每页都需要显示置顶贴，这种情况可以把置顶贴水平切分开来，避免取置顶帖子时从所有帖子的表中读取。

## 分表和分区

分表从表面意思说就是把一张表分成多个小表，分区则是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。

***分表和分区的区别:***

1. 实现方式上

   a），mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。

   ```mysql
   [root@BlackGhost test]# ls |grep user
   alluser.MRG
   alluser.frm
   user1.MYD
   user1.MYI
   user1.frm
   user2.MYD
   user2.MYI
   user2.frm
   ```

   简 单说明一下，上面的分表呢是利用了merge存储引擎（分表的一种），alluser是总表，下面有二个分表，user1，user2。他们二个都是独立 的表，取数据的时候，我们可以通过总表来取。这里总表是没有.MYD,.MYI这二个文件的，也就是说，总表他不是一张表，没有数据，数据都放在分表里面。我们来看看.MRG到底是什么东西

   ```mysql
   [root@BlackGhost test]# cat alluser.MRG |more
   user1
   user2
   #INSERT_METHOD=LAST 
   ```

   从上面我们可以看出，alluser.MRG里面就存了一些分表的关系，以及插入数据的方式。可以把总表理解成一个外壳，或者是联接池。

   b），分区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了。

   ```mysql
   [root@BlackGhost test]# ls |grep aa
   aa#P#p1.MYD
   aa#P#p1.MYI
   aa#P#p3.MYD
   aa#P#p3.MYI
   aa.frm
   aa.par
   ```

   从 上面我们可以看出，aa这张表，分为二个区，p1和p3，本来是三个区，被我删了一个区。我们都知道一张表对应三个文件.MYD,.MYI,.frm。分区呢根据一定的规则把数据文件和索引文件进行了分割，还多出了一个.par文件，打开.par文件后你可以看出他记录了，这张表的分区信息，根分表中 的.MRG有点像。分区后，还是一张，而不是多张表。

   如

   ```mysql
   orderid,userid,ordertime,.....
   ordertime<2015-01-01 #p0
   ordertime<2015-04-01 #p1
   ordertime<2015-07-01 #p2
   ordertime<2015-10-01 #p3
   ordertime<2016-01-01 #p4
   ```


   按照时间分区。大部分只查询最近的订单数据，那么大部分只访问一个分区，比整个表小多了，数据库可以更加好的缓存，性能也提高了。这个是数据库分的，应用程序透明，无需修改。

2. 数据处理上

   a），分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。看下面的例子：

   select * from alluser where id='12'表面上看，是对表alluser进行操作的，其实不是的。是对alluser里面的分表进行了操作。

   b），分区呢，不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表呢，还是一张表。数据处理还是由自己来完成。

3. 提高性能上

   a）， 分表后，**单表的并发能力提高了，磁盘I/O性能也提高了**。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同 的查询，将并发压力分到不同的小表里面。磁盘I/O性能怎么搞高了呢，本来一个非常大的.MYD文件现在也分摊到各个小表的.MYD中去了。

   b），mysql提出了分区的概念，我觉得就想**突破磁盘I/O瓶颈，想提高磁盘的读写能力**，来增加mysql性能。
   在这一点上，**分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。**

4. 实现的难易度上

   a），分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式根分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。

   b），分区实现是比较简单的，建立分区表，根建平常的表没什么区别，并且对开代码端来说是透明的。

***分区和分表使用场景***

**分区的使用场景**

1.一张表的查询速度已经慢到影响使用的时候。
2.表中的数据是分段的
3.对数据的操作往往只涉及一部分数据，而不是所有的数据

**分表的适用场景**

1.一张表的查询速度已经慢到影响使用的时候。
2.当频繁插入或者联合查询时，速度变慢。
3.分表的实现需要业务结合实现和迁移，较为复杂。

***分表和分区联系***

**1，都能提高mysql的性高，在高并发状态下都有一个良好的表面。**

2，**分表和分区不矛盾**，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式（如果merge这种分表方式，不能和分区配合的话，可以用其他的分表试），访问量不大，但是表数据很多的表，我们可以采取分区的方式等。

## 分库

分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库。

与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由。

**分库分表区别：**

1. 基本思想之什么是分库分表？
   从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。

2. 基本思想之为什么要分库分表？

   数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈,。

3. 分库分表的实施策略。

   如果你的单机性能很低了，那可以尝试分库。分库，业务透明，在物理实现上分成多个服务器，不同的分库在不同服务器上。分区可以把表分到不同的硬盘上，但不能分配到不同服务器上。一台机器的性能是有限制的，用分库可以解决单台服务器性能不够，或者成本过高问题。
   当分区之后，表还是很大，处理不过来，这时候可以用分库。
   orderid,userid,ordertime,.....
   userid%4=0，用分库1
   userid%4=1，用分库2
   userid%4=2, 用分库3
   userid%4=3，用分库4
   上面这个就是一个简单的分库路由，根据userid选择分库，即不同的服务器

4. 分库分表存在的问题。

   - 事务问题。

     在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。

   - 跨库跨表的join问题。

     在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。

   - 额外的数据管理负担和数据运算压力。
     额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。